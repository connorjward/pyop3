#!/usr/bin/env python

import argparse
import subprocess

import matplotlib as mpl
import numpy as np
import pymbolic as pym
import pyop3
import svgwrite


CELL_HEIGHT = 30
MAX_WIDTH = 600
TOP_BORDER = 50

COLORMAP = mpl.cm.get_cmap("plasma")


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("-o", dest="filename", type=str, default="tensor.svg")
    return parser.parse_args()


def split_array(array, n):
    """Split an array into n roughly equal sized parts.

    This is useful for dividing the values of a colormap.
    """
    k, m = divmod(len(array), n)
    return tuple(array[i*k+min(i, m):(i+1)*k+min(i+1, m)] for i in range(n))


def get_dim_size(dim):
    _, sizess = pyop3.Tensor._collect_sections_unpermuted_array(dim, include_size=True)
    return sum(sum(sizes) for sizes in sizess)


# TODO do something clever with redefining coordinates or something
def draw(drawing, dim, *, xmin=0, xmax=MAX_WIDTH, ypos=TOP_BORDER, colormap=COLORMAP.colors):
    draw_array(drawing, dim, xmin=xmin, xmax=xmax, y=ypos, colormap=colormap)

    cmaps = split_array(colormap, len(dim.sizes))

    # now draw all subdims
    # divide the drawing area s.t. smaller subdims have less space
    all_sizes = [get_dim_size(subdim) for subdim in dim.subdims]
    total_size = sum(all_sizes) + 1

    xmin_ = xmin
    for subdim, size, cmap in zip(dim.subdims, all_sizes, cmaps):
        width = size / total_size * (xmax - xmin)
        if size != 1:
            draw(drawing, subdim, xmin=xmin_, xmax=xmin_+width, ypos=ypos+80, colormap=cmap)
        xmin_ += width + 30  # buffer


def draw_array(drawing, dim, *, xmin=0, xmax=MAX_WIDTH, y=TOP_BORDER, colormap=COLORMAP.colors, inner=False):
    colormaps = split_array(colormap, len(dim.sizes))
    if dim.permutation:
        raise NotImplementedError
    else:
        sections, sizess = pyop3.Tensor._collect_sections_unpermuted_array(dim, include_size=True)

    # breakpoint()
    scaling = (xmax-xmin) / get_dim_size(dim)

    number = 0
    for subdim_id, (dsize, ptrs, steps, cmap) in enumerate(zip(dim.sizes, sections, sizess, colormaps)):
        # use the middle value
        color = cmap[len(cmap) // 2]
        color_css = f"rgb({','.join([str(int(c*256)) for c in color[:3]])})"

        for ptr, step in zip(ptrs, steps):
            x = xmin + float(ptr*scaling)
            pos = x, y

            xsize = float(step*scaling)
            ysize = CELL_HEIGHT
            size = xsize, ysize

            # do the inner bit first so we can draw on top of it
            # if we have subdims then we can sketch these in to this layer for added detail
            # do outside other loop
            # do not do this if we are already 'inside'
            if dim.subdims and not inner:
                subdim = dim.subdims[subdim_id]
                draw_array(drawing, subdim, xmin=x, xmax=x+xsize, y=y, colormap=cmap, inner=True)


            rect_kwargs = {}

            # only draw lines around the box if not inner
            if not inner:
                rect_kwargs = {
                    "stroke": "black",
                    "stroke_width": 3,
                }

            if inner or not dim.subdims:
                rect_kwargs["fill"] = color_css
            else:
                rect_kwargs["fill"] = "none"


            rect = drawing.rect(pos, size, **rect_kwargs)
            drawing.add(rect)

            # add a dashed line if inner
            # do not do if first item
            if inner and ptr != 0:
                line_opts = {
                    "stroke": "black",
                    "stroke_width": 1,
                    "stroke_dasharray": 2,
                }
                start = pos
                stop = x, y+ysize
                line = drawing.line(start, stop, **line_opts)
                drawing.add(line)

            # add a label
            if not inner:
                if dim.permutation:
                    raise NotImplementedError
                else:
                    label = drawing.text(str(number), x=[x], y=[y], dx=[xsize//2], dy=[-5], text_anchor="middle")
                    drawing.add(label)

            number += 1


if __name__ == "__main__":
    args = parse_args()
    drawing = svgwrite.Drawing(args.filename)

    # simple
    # tensor = pyop3.Tensor.new(pyop3.Dim((4, 5)), dtype=np.float64)

    # nested
    # tensor = pyop3.Tensor.new(pyop3.Dim((4, 5), subdims=(pyop3.Dim(2), pyop3.Dim(3))), dtype=np.float64)

    # extra nesting
    tensor = pyop3.Tensor.new(pyop3.Dim((4, 5), subdims=(pyop3.Dim((2, 3), subdims=(pyop3.Dim(2), pyop3.Dim(1))), pyop3.Dim((2, 1), subdims=(pyop3.Dim(1), pyop3.Dim(1))))), dtype=np.float64)

    # ragged
    # tensor = pyop3.Tensor.new(pyop3.Dim((4, 5), subdims=(pyop3.Dim(2), pyop3.Dim(3))), dtype=np.float64)

    # permuted
    # tensor = pyop3.Tensor.new(pyop3.Dim((3, 2), permutation=(3, 2, 1, 4, 0)), dtype=np.float64)

    draw(drawing, tensor.dim)
    drawing.save()
